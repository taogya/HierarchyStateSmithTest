// Autogenerated with StateSmith 0.19.0+b5719011215d41a81572ed347c02b22db5d1a48f.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Whatever you put in this `FileTop` section will end up 
// being printed at the top of every generated code file.

#include "HierarchySm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

extern void HSM_INIT_enter(void);
extern void HSM_INIT_exit(void);
extern void HSM_WAIT_enter(void);
extern void HSM_WAIT_exit(void);
extern void HSM_PROC_enter(void);
extern void HSM_PROC_exit(void);
extern void HSM_PROC_OFF_enter(void);
extern void HSM_PROC_OFF_exit(void);
extern void HSM_PROC_ON_enter(void);
extern void HSM_PROC_ON_exit(void);
extern void HSM_PROC_ON_WAIT_enter(void);
extern void HSM_PROC_ON_WAIT_exit(void);
extern void HSM_PROC_ON_EXEC_enter(void);
extern void HSM_PROC_ON_EXEC_exit(void);
extern void HSM_PROC_ON_EXEC_SINGLE_enter(void);
extern void HSM_PROC_ON_EXEC_SINGLE_exit(void);
extern void HSM_PROC_ON_EXEC_MULTI_enter(void);
extern void HSM_PROC_ON_EXEC_MULTI_exit(void);


// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(HierarchySm* sm, HierarchySm_StateId desired_state);

static void ROOT_enter(HierarchySm* sm);

static void INIT_enter(HierarchySm* sm);

static void INIT_exit(HierarchySm* sm);

static void INIT_goto_wait(HierarchySm* sm);

static void PROC_enter(HierarchySm* sm);

static void PROC_exit(HierarchySm* sm);

static void PROC_goto_wait(HierarchySm* sm);

static void PROC_OFF_enter(HierarchySm* sm);

static void PROC_OFF_exit(HierarchySm* sm);

static void PROC_OFF_proc_on(HierarchySm* sm);

static void PROC_ON_enter(HierarchySm* sm);

static void PROC_ON_exit(HierarchySm* sm);

static void PROC_ON_proc_off(HierarchySm* sm);

static void PROC_ON_InitialState_transition(HierarchySm* sm);

static void PROC_ON_EXEC_enter(HierarchySm* sm);

static void PROC_ON_EXEC_exit(HierarchySm* sm);

static void PROC_ON_EXEC_proc_wait(HierarchySm* sm);

static void PROC_ON_EXEC_InitialState_transition(HierarchySm* sm);

static void PROC_ON_EXEC_MULTI_enter(HierarchySm* sm);

static void PROC_ON_EXEC_MULTI_exit(HierarchySm* sm);

static void PROC_ON_EXEC_MULTI_proc_single(HierarchySm* sm);

static void PROC_ON_EXEC_SINGLE_enter(HierarchySm* sm);

static void PROC_ON_EXEC_SINGLE_exit(HierarchySm* sm);

static void PROC_ON_EXEC_SINGLE_proc_multi(HierarchySm* sm);

static void PROC_ON_WAIT_enter(HierarchySm* sm);

static void PROC_ON_WAIT_exit(HierarchySm* sm);

static void PROC_ON_WAIT_proc_exec(HierarchySm* sm);

static void WAIT_enter(HierarchySm* sm);

static void WAIT_exit(HierarchySm* sm);

static void WAIT_goto_proc(HierarchySm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void HierarchySm_ctor(HierarchySm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void HierarchySm_start(HierarchySm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(INIT)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `INIT`.
            INIT_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `event_id` parameter is valid.
void HierarchySm_dispatch_event(HierarchySm* sm, HierarchySm_EventId event_id)
{
    switch (sm->state_id)
    {
        // STATE: HierarchySm
        case HierarchySm_StateId_ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: INIT
        case HierarchySm_StateId_INIT:
            switch (event_id)
            {
                case HierarchySm_EventId_GOTO_WAIT: INIT_goto_wait(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: PROC
        case HierarchySm_StateId_PROC:
            switch (event_id)
            {
                case HierarchySm_EventId_GOTO_WAIT: PROC_goto_wait(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: PROC_OFF
        case HierarchySm_StateId_PROC_OFF:
            switch (event_id)
            {
                case HierarchySm_EventId_PROC_ON: PROC_OFF_proc_on(sm); break;
                case HierarchySm_EventId_GOTO_WAIT: PROC_goto_wait(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: PROC_ON
        case HierarchySm_StateId_PROC_ON:
            switch (event_id)
            {
                case HierarchySm_EventId_PROC_OFF: PROC_ON_proc_off(sm); break;
                case HierarchySm_EventId_GOTO_WAIT: PROC_goto_wait(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: PROC_ON_EXEC
        case HierarchySm_StateId_PROC_ON_EXEC:
            switch (event_id)
            {
                case HierarchySm_EventId_PROC_WAIT: PROC_ON_EXEC_proc_wait(sm); break;
                case HierarchySm_EventId_GOTO_WAIT: PROC_goto_wait(sm); break; // First ancestor handler for this event
                case HierarchySm_EventId_PROC_OFF: PROC_ON_proc_off(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: PROC_ON_EXEC_MULTI
        case HierarchySm_StateId_PROC_ON_EXEC_MULTI:
            switch (event_id)
            {
                case HierarchySm_EventId_PROC_SINGLE: PROC_ON_EXEC_MULTI_proc_single(sm); break;
                case HierarchySm_EventId_GOTO_WAIT: PROC_goto_wait(sm); break; // First ancestor handler for this event
                case HierarchySm_EventId_PROC_OFF: PROC_ON_proc_off(sm); break; // First ancestor handler for this event
                case HierarchySm_EventId_PROC_WAIT: PROC_ON_EXEC_proc_wait(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: PROC_ON_EXEC_SINGLE
        case HierarchySm_StateId_PROC_ON_EXEC_SINGLE:
            switch (event_id)
            {
                case HierarchySm_EventId_PROC_MULTI: PROC_ON_EXEC_SINGLE_proc_multi(sm); break;
                case HierarchySm_EventId_GOTO_WAIT: PROC_goto_wait(sm); break; // First ancestor handler for this event
                case HierarchySm_EventId_PROC_OFF: PROC_ON_proc_off(sm); break; // First ancestor handler for this event
                case HierarchySm_EventId_PROC_WAIT: PROC_ON_EXEC_proc_wait(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: PROC_ON_WAIT
        case HierarchySm_StateId_PROC_ON_WAIT:
            switch (event_id)
            {
                case HierarchySm_EventId_PROC_EXEC: PROC_ON_WAIT_proc_exec(sm); break;
                case HierarchySm_EventId_GOTO_WAIT: PROC_goto_wait(sm); break; // First ancestor handler for this event
                case HierarchySm_EventId_PROC_OFF: PROC_ON_proc_off(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: WAIT
        case HierarchySm_StateId_WAIT:
            switch (event_id)
            {
                case HierarchySm_EventId_GOTO_PROC: WAIT_goto_proc(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(HierarchySm* sm, HierarchySm_StateId desired_state)
{
    while (sm->state_id != desired_state)
    {
        switch (sm->state_id)
        {
            case HierarchySm_StateId_INIT: INIT_exit(sm); break;
            
            case HierarchySm_StateId_PROC: PROC_exit(sm); break;
            
            case HierarchySm_StateId_PROC_OFF: PROC_OFF_exit(sm); break;
            
            case HierarchySm_StateId_PROC_ON: PROC_ON_exit(sm); break;
            
            case HierarchySm_StateId_PROC_ON_EXEC: PROC_ON_EXEC_exit(sm); break;
            
            case HierarchySm_StateId_PROC_ON_EXEC_MULTI: PROC_ON_EXEC_MULTI_exit(sm); break;
            
            case HierarchySm_StateId_PROC_ON_EXEC_SINGLE: PROC_ON_EXEC_SINGLE_exit(sm); break;
            
            case HierarchySm_StateId_PROC_ON_WAIT: PROC_ON_WAIT_exit(sm); break;
            
            case HierarchySm_StateId_WAIT: WAIT_exit(sm); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state INIT
////////////////////////////////////////////////////////////////////////////////

static void INIT_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_INIT;
    
    // INIT behavior
    // uml: enter / { HSM_INIT_enter(); }
    {
        // Step 1: execute action `HSM_INIT_enter();`
        HSM_INIT_enter();
    } // end of behavior for INIT
}

static void INIT_exit(HierarchySm* sm)
{
    // INIT behavior
    // uml: exit / { HSM_INIT_exit(); }
    {
        // Step 1: execute action `HSM_INIT_exit();`
        HSM_INIT_exit();
    } // end of behavior for INIT
    
    sm->state_id = HierarchySm_StateId_ROOT;
}

static void INIT_goto_wait(HierarchySm* sm)
{
    // INIT behavior
    // uml: GOTO_WAIT TransitionTo(WAIT)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        INIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAIT`.
        WAIT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for INIT
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PROC
////////////////////////////////////////////////////////////////////////////////

static void PROC_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_PROC;
    
    // PROC behavior
    // uml: enter / { HSM_PROC_enter(); }
    {
        // Step 1: execute action `HSM_PROC_enter();`
        HSM_PROC_enter();
    } // end of behavior for PROC
}

static void PROC_exit(HierarchySm* sm)
{
    // PROC behavior
    // uml: exit / { HSM_PROC_exit(); }
    {
        // Step 1: execute action `HSM_PROC_exit();`
        HSM_PROC_exit();
    } // end of behavior for PROC
    
    sm->state_id = HierarchySm_StateId_ROOT;
}

static void PROC_goto_wait(HierarchySm* sm)
{
    // PROC behavior
    // uml: GOTO_WAIT TransitionTo(WAIT)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, HierarchySm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAIT`.
        WAIT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PROC
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PROC_OFF
////////////////////////////////////////////////////////////////////////////////

static void PROC_OFF_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_PROC_OFF;
    
    // PROC_OFF behavior
    // uml: enter / { HSM_PROC_OFF_enter(); }
    {
        // Step 1: execute action `HSM_PROC_OFF_enter();`
        HSM_PROC_OFF_enter();
    } // end of behavior for PROC_OFF
    
    // PROC_OFF behavior
    // uml: enter / { $gil(this.vars.PROC_history = PROC_HistoryId.PROC_OFF;) }
    {
        // Step 1: execute action `$gil(this.vars.PROC_history = PROC_HistoryId.PROC_OFF;)`
        sm->vars.PROC_history = HierarchySm_PROC_HistoryId_PROC_OFF;
    } // end of behavior for PROC_OFF
}

static void PROC_OFF_exit(HierarchySm* sm)
{
    // PROC_OFF behavior
    // uml: exit / { HSM_PROC_OFF_exit(); }
    {
        // Step 1: execute action `HSM_PROC_OFF_exit();`
        HSM_PROC_OFF_exit();
    } // end of behavior for PROC_OFF
    
    sm->state_id = HierarchySm_StateId_PROC;
}

static void PROC_OFF_proc_on(HierarchySm* sm)
{
    // PROC_OFF behavior
    // uml: PROC_ON TransitionTo(PROC_ON)
    {
        // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition).
        PROC_OFF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC_ON`.
        PROC_ON_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        PROC_ON_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for PROC_OFF
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PROC_ON
////////////////////////////////////////////////////////////////////////////////

static void PROC_ON_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_PROC_ON;
    
    // PROC_ON behavior
    // uml: enter / { HSM_PROC_ON_enter(); }
    {
        // Step 1: execute action `HSM_PROC_ON_enter();`
        HSM_PROC_ON_enter();
    } // end of behavior for PROC_ON
    
    // PROC_ON behavior
    // uml: enter / { $gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON;) }
    {
        // Step 1: execute action `$gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON;)`
        sm->vars.PROC_history = HierarchySm_PROC_HistoryId_PROC_ON;
    } // end of behavior for PROC_ON
}

static void PROC_ON_exit(HierarchySm* sm)
{
    // PROC_ON behavior
    // uml: exit / { HSM_PROC_ON_exit(); }
    {
        // Step 1: execute action `HSM_PROC_ON_exit();`
        HSM_PROC_ON_exit();
    } // end of behavior for PROC_ON
    
    sm->state_id = HierarchySm_StateId_PROC;
}

static void PROC_ON_proc_off(HierarchySm* sm)
{
    // PROC_ON behavior
    // uml: PROC_OFF TransitionTo(PROC_OFF)
    {
        // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, HierarchySm_StateId_PROC);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC_OFF`.
        PROC_OFF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PROC_ON
    
    // No ancestor handles this event.
}

static void PROC_ON_InitialState_transition(HierarchySm* sm)
{
    // PROC_ON.<InitialState> behavior
    // uml: TransitionTo(PROC_ON_WAIT)
    {
        // Step 1: Exit states until we reach `PROC_ON` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC_ON_WAIT`.
        PROC_ON_WAIT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PROC_ON.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PROC_ON_EXEC
////////////////////////////////////////////////////////////////////////////////

static void PROC_ON_EXEC_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_PROC_ON_EXEC;
    
    // PROC_ON_EXEC behavior
    // uml: enter / { HSM_PROC_ON_EXEC_enter(); }
    {
        // Step 1: execute action `HSM_PROC_ON_EXEC_enter();`
        HSM_PROC_ON_EXEC_enter();
    } // end of behavior for PROC_ON_EXEC
    
    // PROC_ON_EXEC behavior
    // uml: enter / { $gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON_EXEC;) }
    {
        // Step 1: execute action `$gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON_EXEC;)`
        sm->vars.PROC_history = HierarchySm_PROC_HistoryId_PROC_ON_EXEC;
    } // end of behavior for PROC_ON_EXEC
}

static void PROC_ON_EXEC_exit(HierarchySm* sm)
{
    // PROC_ON_EXEC behavior
    // uml: exit / { HSM_PROC_ON_EXEC_exit(); }
    {
        // Step 1: execute action `HSM_PROC_ON_EXEC_exit();`
        HSM_PROC_ON_EXEC_exit();
    } // end of behavior for PROC_ON_EXEC
    
    sm->state_id = HierarchySm_StateId_PROC_ON;
}

static void PROC_ON_EXEC_proc_wait(HierarchySm* sm)
{
    // PROC_ON_EXEC behavior
    // uml: PROC_WAIT TransitionTo(PROC_ON_WAIT)
    {
        // Step 1: Exit states until we reach `PROC_ON` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, HierarchySm_StateId_PROC_ON);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC_ON_WAIT`.
        PROC_ON_WAIT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PROC_ON_EXEC
    
    // No ancestor handles this event.
}

static void PROC_ON_EXEC_InitialState_transition(HierarchySm* sm)
{
    // PROC_ON_EXEC.<InitialState> behavior
    // uml: TransitionTo(PROC_ON_EXEC.<History>)
    {
        // Step 1: Exit states until we reach `PROC_ON_EXEC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC_ON_EXEC.<History>`.
        // PROC_ON_EXEC.<History> is a pseudo state and cannot have an `enter` trigger.
        
        // PROC_ON_EXEC.<History> behavior
        // uml: [$gil(this.vars.PROC_ON_EXEC_history == PROC_ON_EXEC_HistoryId.PROC_ON_EXEC_MULTI)] TransitionTo(PROC_ON_EXEC_MULTI)
        if (sm->vars.PROC_ON_EXEC_history == HierarchySm_PROC_ON_EXEC_HistoryId_PROC_ON_EXEC_MULTI)
        {
            // Step 1: Exit states until we reach `PROC_ON_EXEC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PROC_ON_EXEC_MULTI`.
            PROC_ON_EXEC_MULTI_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PROC_ON_EXEC.<History>
        
        // PROC_ON_EXEC.<History> behavior
        // uml: else TransitionTo(PROC_ON_EXEC_SINGLE)
        {
            // Step 1: Exit states until we reach `PROC_ON_EXEC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PROC_ON_EXEC_SINGLE`.
            PROC_ON_EXEC_SINGLE_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PROC_ON_EXEC.<History>
    } // end of behavior for PROC_ON_EXEC.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PROC_ON_EXEC_MULTI
////////////////////////////////////////////////////////////////////////////////

static void PROC_ON_EXEC_MULTI_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_PROC_ON_EXEC_MULTI;
    
    // PROC_ON_EXEC_MULTI behavior
    // uml: enter / { HSM_PROC_ON_EXEC_MULTI_enter(); }
    {
        // Step 1: execute action `HSM_PROC_ON_EXEC_MULTI_enter();`
        HSM_PROC_ON_EXEC_MULTI_enter();
    } // end of behavior for PROC_ON_EXEC_MULTI
    
    // PROC_ON_EXEC_MULTI behavior
    // uml: enter / { $gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON_EXEC_MULTI;) }
    {
        // Step 1: execute action `$gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON_EXEC_MULTI;)`
        sm->vars.PROC_history = HierarchySm_PROC_HistoryId_PROC_ON_EXEC_MULTI;
    } // end of behavior for PROC_ON_EXEC_MULTI
    
    // PROC_ON_EXEC_MULTI behavior
    // uml: enter / { $gil(this.vars.PROC_ON_EXEC_history = PROC_ON_EXEC_HistoryId.PROC_ON_EXEC_MULTI;) }
    {
        // Step 1: execute action `$gil(this.vars.PROC_ON_EXEC_history = PROC_ON_EXEC_HistoryId.PROC_ON_EXEC_MULTI;)`
        sm->vars.PROC_ON_EXEC_history = HierarchySm_PROC_ON_EXEC_HistoryId_PROC_ON_EXEC_MULTI;
    } // end of behavior for PROC_ON_EXEC_MULTI
}

static void PROC_ON_EXEC_MULTI_exit(HierarchySm* sm)
{
    // PROC_ON_EXEC_MULTI behavior
    // uml: exit / { HSM_PROC_ON_EXEC_MULTI_exit(); }
    {
        // Step 1: execute action `HSM_PROC_ON_EXEC_MULTI_exit();`
        HSM_PROC_ON_EXEC_MULTI_exit();
    } // end of behavior for PROC_ON_EXEC_MULTI
    
    sm->state_id = HierarchySm_StateId_PROC_ON_EXEC;
}

static void PROC_ON_EXEC_MULTI_proc_single(HierarchySm* sm)
{
    // PROC_ON_EXEC_MULTI behavior
    // uml: PROC_SINGLE TransitionTo(PROC_ON_EXEC_SINGLE)
    {
        // Step 1: Exit states until we reach `PROC_ON_EXEC` state (Least Common Ancestor for transition).
        PROC_ON_EXEC_MULTI_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC_ON_EXEC_SINGLE`.
        PROC_ON_EXEC_SINGLE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PROC_ON_EXEC_MULTI
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PROC_ON_EXEC_SINGLE
////////////////////////////////////////////////////////////////////////////////

static void PROC_ON_EXEC_SINGLE_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_PROC_ON_EXEC_SINGLE;
    
    // PROC_ON_EXEC_SINGLE behavior
    // uml: enter / { HSM_PROC_ON_EXEC_SINGLE_enter(); }
    {
        // Step 1: execute action `HSM_PROC_ON_EXEC_SINGLE_enter();`
        HSM_PROC_ON_EXEC_SINGLE_enter();
    } // end of behavior for PROC_ON_EXEC_SINGLE
    
    // PROC_ON_EXEC_SINGLE behavior
    // uml: enter / { $gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON_EXEC_SINGLE;) }
    {
        // Step 1: execute action `$gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON_EXEC_SINGLE;)`
        sm->vars.PROC_history = HierarchySm_PROC_HistoryId_PROC_ON_EXEC_SINGLE;
    } // end of behavior for PROC_ON_EXEC_SINGLE
    
    // PROC_ON_EXEC_SINGLE behavior
    // uml: enter / { $gil(this.vars.PROC_ON_EXEC_history = PROC_ON_EXEC_HistoryId.PROC_ON_EXEC_SINGLE;) }
    {
        // Step 1: execute action `$gil(this.vars.PROC_ON_EXEC_history = PROC_ON_EXEC_HistoryId.PROC_ON_EXEC_SINGLE;)`
        sm->vars.PROC_ON_EXEC_history = HierarchySm_PROC_ON_EXEC_HistoryId_PROC_ON_EXEC_SINGLE;
    } // end of behavior for PROC_ON_EXEC_SINGLE
}

static void PROC_ON_EXEC_SINGLE_exit(HierarchySm* sm)
{
    // PROC_ON_EXEC_SINGLE behavior
    // uml: exit / { HSM_PROC_ON_EXEC_SINGLE_exit(); }
    {
        // Step 1: execute action `HSM_PROC_ON_EXEC_SINGLE_exit();`
        HSM_PROC_ON_EXEC_SINGLE_exit();
    } // end of behavior for PROC_ON_EXEC_SINGLE
    
    sm->state_id = HierarchySm_StateId_PROC_ON_EXEC;
}

static void PROC_ON_EXEC_SINGLE_proc_multi(HierarchySm* sm)
{
    // PROC_ON_EXEC_SINGLE behavior
    // uml: PROC_MULTI TransitionTo(PROC_ON_EXEC_MULTI)
    {
        // Step 1: Exit states until we reach `PROC_ON_EXEC` state (Least Common Ancestor for transition).
        PROC_ON_EXEC_SINGLE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC_ON_EXEC_MULTI`.
        PROC_ON_EXEC_MULTI_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for PROC_ON_EXEC_SINGLE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PROC_ON_WAIT
////////////////////////////////////////////////////////////////////////////////

static void PROC_ON_WAIT_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_PROC_ON_WAIT;
    
    // PROC_ON_WAIT behavior
    // uml: enter / { HSM_PROC_ON_WAIT_enter(); }
    {
        // Step 1: execute action `HSM_PROC_ON_WAIT_enter();`
        HSM_PROC_ON_WAIT_enter();
    } // end of behavior for PROC_ON_WAIT
    
    // PROC_ON_WAIT behavior
    // uml: enter / { $gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON_WAIT;) }
    {
        // Step 1: execute action `$gil(this.vars.PROC_history = PROC_HistoryId.PROC_ON_WAIT;)`
        sm->vars.PROC_history = HierarchySm_PROC_HistoryId_PROC_ON_WAIT;
    } // end of behavior for PROC_ON_WAIT
}

static void PROC_ON_WAIT_exit(HierarchySm* sm)
{
    // PROC_ON_WAIT behavior
    // uml: exit / { HSM_PROC_ON_WAIT_exit(); }
    {
        // Step 1: execute action `HSM_PROC_ON_WAIT_exit();`
        HSM_PROC_ON_WAIT_exit();
    } // end of behavior for PROC_ON_WAIT
    
    sm->state_id = HierarchySm_StateId_PROC_ON;
}

static void PROC_ON_WAIT_proc_exec(HierarchySm* sm)
{
    // PROC_ON_WAIT behavior
    // uml: PROC_EXEC TransitionTo(PROC_ON_EXEC)
    {
        // Step 1: Exit states until we reach `PROC_ON` state (Least Common Ancestor for transition).
        PROC_ON_WAIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC_ON_EXEC`.
        PROC_ON_EXEC_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        PROC_ON_EXEC_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for PROC_ON_WAIT
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WAIT
////////////////////////////////////////////////////////////////////////////////

static void WAIT_enter(HierarchySm* sm)
{
    sm->state_id = HierarchySm_StateId_WAIT;
    
    // WAIT behavior
    // uml: enter / { HSM_WAIT_enter(); }
    {
        // Step 1: execute action `HSM_WAIT_enter();`
        HSM_WAIT_enter();
    } // end of behavior for WAIT
}

static void WAIT_exit(HierarchySm* sm)
{
    // WAIT behavior
    // uml: exit / { HSM_WAIT_exit(); }
    {
        // Step 1: execute action `HSM_WAIT_exit();`
        HSM_WAIT_exit();
    } // end of behavior for WAIT
    
    sm->state_id = HierarchySm_StateId_ROOT;
}

static void WAIT_goto_proc(HierarchySm* sm)
{
    // WAIT behavior
    // uml: GOTO_PROC TransitionTo(PROC)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        WAIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `PROC`.
        PROC_enter(sm);
        
        // PROC.<InitialState> behavior
        // uml: TransitionTo(PROC.<History>)
        {
            // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `PROC.<History>`.
            // PROC.<History> is a pseudo state and cannot have an `enter` trigger.
            
            // PROC.<History> behavior
            // uml: [$gil(this.vars.PROC_history == PROC_HistoryId.PROC_ON)] TransitionTo(PROC_ON)
            if (sm->vars.PROC_history == HierarchySm_PROC_HistoryId_PROC_ON)
            {
                // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PROC_ON`.
                PROC_ON_enter(sm);
                
                // Finish transition by calling pseudo state transition function.
                PROC_ON_InitialState_transition(sm);
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for PROC.<History>
            
            // PROC.<History> behavior
            // uml: [$gil(this.vars.PROC_history == PROC_HistoryId.PROC_ON_WAIT)] TransitionTo(PROC_ON_WAIT)
            if (sm->vars.PROC_history == HierarchySm_PROC_HistoryId_PROC_ON_WAIT)
            {
                // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PROC_ON_WAIT`.
                PROC_ON_enter(sm);
                PROC_ON_WAIT_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for PROC.<History>
            
            // PROC.<History> behavior
            // uml: [$gil(this.vars.PROC_history == PROC_HistoryId.PROC_ON_EXEC)] TransitionTo(PROC_ON_EXEC)
            if (sm->vars.PROC_history == HierarchySm_PROC_HistoryId_PROC_ON_EXEC)
            {
                // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PROC_ON_EXEC`.
                PROC_ON_enter(sm);
                PROC_ON_EXEC_enter(sm);
                
                // Finish transition by calling pseudo state transition function.
                PROC_ON_EXEC_InitialState_transition(sm);
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for PROC.<History>
            
            // PROC.<History> behavior
            // uml: [$gil(this.vars.PROC_history == PROC_HistoryId.PROC_ON_EXEC_SINGLE)] TransitionTo(PROC_ON_EXEC_SINGLE)
            if (sm->vars.PROC_history == HierarchySm_PROC_HistoryId_PROC_ON_EXEC_SINGLE)
            {
                // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PROC_ON_EXEC_SINGLE`.
                PROC_ON_enter(sm);
                PROC_ON_EXEC_enter(sm);
                PROC_ON_EXEC_SINGLE_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for PROC.<History>
            
            // PROC.<History> behavior
            // uml: [$gil(this.vars.PROC_history == PROC_HistoryId.PROC_ON_EXEC_MULTI)] TransitionTo(PROC_ON_EXEC_MULTI)
            if (sm->vars.PROC_history == HierarchySm_PROC_HistoryId_PROC_ON_EXEC_MULTI)
            {
                // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PROC_ON_EXEC_MULTI`.
                PROC_ON_enter(sm);
                PROC_ON_EXEC_enter(sm);
                PROC_ON_EXEC_MULTI_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for PROC.<History>
            
            // PROC.<History> behavior
            // uml: else TransitionTo(PROC_OFF)
            {
                // Step 1: Exit states until we reach `PROC` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `PROC_OFF`.
                PROC_OFF_enter(sm);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for PROC.<History>
        } // end of behavior for PROC.<InitialState>
    } // end of behavior for WAIT
    
    // No ancestor handles this event.
}

// Thread safe.
char const * HierarchySm_state_id_to_string(HierarchySm_StateId id)
{
    switch (id)
    {
        case HierarchySm_StateId_ROOT: return "ROOT";
        case HierarchySm_StateId_INIT: return "INIT";
        case HierarchySm_StateId_PROC: return "PROC";
        case HierarchySm_StateId_PROC_OFF: return "PROC_OFF";
        case HierarchySm_StateId_PROC_ON: return "PROC_ON";
        case HierarchySm_StateId_PROC_ON_EXEC: return "PROC_ON_EXEC";
        case HierarchySm_StateId_PROC_ON_EXEC_MULTI: return "PROC_ON_EXEC_MULTI";
        case HierarchySm_StateId_PROC_ON_EXEC_SINGLE: return "PROC_ON_EXEC_SINGLE";
        case HierarchySm_StateId_PROC_ON_WAIT: return "PROC_ON_WAIT";
        case HierarchySm_StateId_WAIT: return "WAIT";
        default: return "?";
    }
}

// Thread safe.
char const * HierarchySm_event_id_to_string(HierarchySm_EventId id)
{
    switch (id)
    {
        case HierarchySm_EventId_GOTO_PROC: return "GOTO_PROC";
        case HierarchySm_EventId_GOTO_WAIT: return "GOTO_WAIT";
        case HierarchySm_EventId_PROC_EXEC: return "PROC_EXEC";
        case HierarchySm_EventId_PROC_MULTI: return "PROC_MULTI";
        case HierarchySm_EventId_PROC_OFF: return "PROC_OFF";
        case HierarchySm_EventId_PROC_ON: return "PROC_ON";
        case HierarchySm_EventId_PROC_SINGLE: return "PROC_SINGLE";
        case HierarchySm_EventId_PROC_WAIT: return "PROC_WAIT";
        default: return "?";
    }
}
